<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인터랙티브 스크롤 플레이스홀더</title>
    <!-- Google Fonts 'Poppins' 불러오기 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0c0a14;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #placeholderCanvas {
            display: block;
            box-shadow: 0 10px 50px rgba(50, 150, 255, 0.2);
            border-radius: 8px;
            /* 스크롤 가능할 때 커서 모양 변경 */
            cursor: grab;
        }
        #placeholderCanvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <canvas id="placeholderCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('placeholderCanvas');
            const ctx = canvas.getContext('2d');
            
            // --- 전역 상태 변수 ---
            let animationFrameId;
            let stars = [];
            const numStars = 300;

            // 스크롤 관련 상태
            let scrollY = 0;
            let isDragging = false;
            let lastDragY = 0;
            let totalTextHeight = 0;
            let maxScroll = 0;


            // --- 헬퍼 함수 ---
            function wrapText(context, text, maxWidth) {
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0] || '';
                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    if (context.measureText(currentLine + " " + word).width < maxWidth) {
                        currentLine += " " + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            // --- 애니메이션 및 그리기 함수 ---
            function initStars(width, height) {
                stars = [];
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        radius: Math.random() * 1.5,
                        alpha: Math.random() * 0.5 + 0.5,
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: (Math.random() - 0.5) * 0.1,
                    });
                }
            }

            function drawCosmicBackground(width, height) {
                const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) * 0.7);
                gradient.addColorStop(0, '#3a4a7a');
                gradient.addColorStop(1, '#111827');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                stars.forEach(star => {
                    star.x += star.vx; star.y += star.vy;
                    if (Math.random() > 0.995) star.alpha = Math.random() * 0.5 + 0.5;
                    if (star.x < 0) star.x = width; if (star.x > width) star.x = 0;
                    if (star.y < 0) star.y = height; if (star.y > height) star.y = 0;
                    ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 224, ${star.alpha})`;
                    ctx.fill();
                });
            }

            function drawScrollbar(width, height) {
                if (maxScroll <= 0) return; // 스크롤이 필요 없으면 그리지 않음

                const scrollbarWidth = 8;
                const trackX = width - scrollbarWidth - 4;
                const trackHeight = height;

                // 스크롤바 트랙
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(trackX, 0, scrollbarWidth, trackHeight);
                
                // 스크롤바 손잡이(thumb)
                const thumbHeight = Math.max(20, (height / totalTextHeight) * height);
                const thumbY = (scrollY / maxScroll) * (height - thumbHeight);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(trackX, thumbY, scrollbarWidth, thumbHeight);
            }
            
            // --- 메인 렌더링 함수 ---
            function render() {
                const width = canvas.width / (window.devicePixelRatio || 1);
                const height = canvas.height / (window.devicePixelRatio || 1);
                
                // 배경 그리기
                const params = new URLSearchParams(window.location.search);
                const userBgColor = params.get('bgColor');
                if (userBgColor) {
                    ctx.fillStyle = `#${userBgColor}`;
                    ctx.fillRect(0, 0, width, height);
                } else {
                    drawCosmicBackground(width, height);
                }

                // 텍스트 설정 및 그리기
                const text = params.get('text') || `This is a scrollable area.\nUse your mouse wheel\nor drag to navigate\nthrough the content.\nThe font size is fixed at 50px.\nEnjoy the cosmic shimmer!`;
                const textColor = params.get('textColor') || '#FFFFFF';

                const horizontalMargin = width * 0.1;
                const textMaxWidth = width - (horizontalMargin * 2);

                ctx.font = `600 50px 'Poppins', sans-serif`; // 고정 폰트 크기 및 Poppins 폰트 적용
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const lines = wrapText(ctx, text, textMaxWidth);
                const lineHeight = 50 * 1.3;
                totalTextHeight = lines.length * lineHeight;
                
                // 스크롤 최대값 계산
                const verticalMargin = height * 0.1;
                maxScroll = Math.max(0, totalTextHeight - height + (verticalMargin * 2));
                
                // 스크롤 위치 제한
                scrollY = Math.max(0, Math.min(scrollY, maxScroll));
                
                // 그리기 시작 Y 위치 계산 (스크롤 적용)
                const startY = (height / 2) - (totalTextHeight / 2) + (lineHeight/2);
                
                ctx.save();
                ctx.rect(0, 0, width, height);
                ctx.clip(); // 캔버스 영역 밖으로 텍스트가 그려지지 않도록 클리핑

                lines.forEach((line, index) => {
                    ctx.fillText(line, width / 2, startY + (index * lineHeight) - scrollY);
                });
                
                ctx.restore();

                // 스크롤바 그리기
                drawScrollbar(width, height);
                
                // 애니메이션 프레임 요청 (애니메이션 배경일 때만)
                if (!userBgColor) {
                    animationFrameId = requestAnimationFrame(render);
                }
            }

            // --- 초기 설정 및 이벤트 리스너 ---
            function setup() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                
                const params = new URLSearchParams(window.location.search);
                const sizeParam = params.get('size')?.split('x');
                const width = parseInt(sizeParam?.[0], 10) || window.innerWidth * 0.8;
                const height = parseInt(sizeParam?.[1], 10) || window.innerHeight * 0.7;

                const dpr = window.devicePixelRatio || 1;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);

                if (!params.get('bgColor')) initStars(width, height);
                
                scrollY = 0; // 리사이즈 시 스크롤 초기화
                render(); // 첫 렌더링
            }

            // 스크롤 이벤트 리스너
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                scrollY += e.deltaY * 0.5; // 스크롤 감도 조절
                if (!new URLSearchParams(window.location.search).has('bgColor')) {
                    // 애니메이션이 아닐 경우, 수동으로 렌더링 호출
                    render();
                }
            });

            canvas.addEventListener('mousedown', (e) => { isDragging = true; lastDragY = e.clientY; });
            canvas.addEventListener('touchstart', (e) => { isDragging = true; lastDragY = e.touches[0].clientY; });
            
            window.addEventListener('mousemove', (e) => { if (!isDragging) return; scrollY += (lastDragY - e.clientY); lastDragY = e.clientY; if (!new URLSearchParams(window.location.search).has('bgColor')) render(); });
            window.addEventListener('touchmove', (e) => { if (!isDragging) return; scrollY += (lastDragY - e.touches[0].clientY); lastDragY = e.touches[0].clientY; if (!new URLSearchParams(window.location.search).has('bgColor')) render(); });

            window.addEventListener('mouseup', () => { isDragging = false; });
            window.addEventListener('touchend', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });

            // --- 실행 ---
            setup();
            if (!new URLSearchParams(window.location.search).has('size')) {
                window.addEventListener('resize', setup);
            }
        });
    </script>
</body>
</html>
